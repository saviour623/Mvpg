#ifdef __ARM_NEON
#include <arm_neon>
//#elif defined(__i386__) || defined(__i386) || defined(x86_64)
#else
#include <mmintrin.h>
#include <immintrin.h>
#include <x86intrin.h>
#include <xmmintrin.h>
#endif
#include <stdint.h>
#include <stdio.h>

typedef __m128i m128i_t;
__m256i __add(uint16_t __a[], uint16_t __b) {
  
}

uint32_t intrinStrlen(const char *str) {
  __m256i = _mm_load_epi8()
}
int main(void) {
  intrinStrlen("we require the size of this string");

  return 0;
}
 __m256i string;

/*
 * load the string
 * compare for zero
 * we need to know the loation of the zero
 */
 _mm_popcnt_u32
  _mm_popcnt_u64
 //pack extend the bit width field
  __m128i _mm_cvtepi8_epi64 (__m128i a)

    __m128i _mm_insert_epi8(__m128i s1, int s2, const int ndx)
 Insert integer byte into packed
 integer array element selected by index

 int _mm_extract_epi8(__m128i src, const int ndx)
 Extract integer byte from packed
 integer array element selected by
 index.
 int _mm_extract_epi8(__m128i src, const int ndx)
 Extract integer byte from packed
 integer array element selected by
 index.
_mm_testc_si128
 _mm_testnzc_si128
 Checks for all ones in specified bits of
 a 128-bit value
 Checks for at least one '0' and at
 least one '1' in the specified bits of a
 128-bit value

 
   
 __m128i _mm_packus_epi32(__m128i m1, __m128i m2)
    Converts eight packed signed doublewords into eight packed unsigned words, using unsigned saturation to
 handle overflow condition.

    extern __m128i _mm_hadd_epi16(__m128i a, __m128i b)
   add horizontally


   extern __m128i _mm_hadd_epi32(__m128i a, __m128i b);
 Adds horizontally packed signed doublewords. Interpreting a, b, and r as arrays of 32-bit signed integers
   